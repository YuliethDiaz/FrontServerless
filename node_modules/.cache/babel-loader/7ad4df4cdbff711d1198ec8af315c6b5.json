{"ast":null,"code":"'use strict';\n/* eslint-disable no-var */\n\nvar reusify = require('reusify');\n\nfunction fastqueue(context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker;\n    worker = context;\n    context = null;\n  }\n\n  if (concurrency < 1) {\n    throw new Error('fastqueue concurrency must be greater than 1');\n  }\n\n  var cache = reusify(Task);\n  var queueHead = null;\n  var queueTail = null;\n  var _running = 0;\n  var errorHandler = null;\n  var self = {\n    push: push,\n    drain: noop,\n    saturated: noop,\n    pause: pause,\n    paused: false,\n    concurrency: concurrency,\n    running: running,\n    resume: resume,\n    idle: idle,\n    length: length,\n    getQueue: getQueue,\n    unshift: unshift,\n    empty: noop,\n    kill: kill,\n    killAndDrain: killAndDrain,\n    error: error\n  };\n  return self;\n\n  function running() {\n    return _running;\n  }\n\n  function pause() {\n    self.paused = true;\n  }\n\n  function length() {\n    var current = queueHead;\n    var counter = 0;\n\n    while (current) {\n      current = current.next;\n      counter++;\n    }\n\n    return counter;\n  }\n\n  function getQueue() {\n    var current = queueHead;\n    var tasks = [];\n\n    while (current) {\n      tasks.push(current.value);\n      current = current.next;\n    }\n\n    return tasks;\n  }\n\n  function resume() {\n    if (!self.paused) return;\n    self.paused = false;\n\n    for (var i = 0; i < self.concurrency; i++) {\n      _running++;\n      release();\n    }\n  }\n\n  function idle() {\n    return _running === 0 && self.length() === 0;\n  }\n\n  function push(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n    current.errorHandler = errorHandler;\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueTail) {\n        queueTail.next = current;\n        queueTail = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n\n  function unshift(value, done) {\n    var current = cache.get();\n    current.context = context;\n    current.release = release;\n    current.value = value;\n    current.callback = done || noop;\n\n    if (_running === self.concurrency || self.paused) {\n      if (queueHead) {\n        current.next = queueHead;\n        queueHead = current;\n      } else {\n        queueHead = current;\n        queueTail = current;\n        self.saturated();\n      }\n    } else {\n      _running++;\n      worker.call(context, current.value, current.worked);\n    }\n  }\n\n  function release(holder) {\n    if (holder) {\n      cache.release(holder);\n    }\n\n    var next = queueHead;\n\n    if (next) {\n      if (!self.paused) {\n        if (queueTail === queueHead) {\n          queueTail = null;\n        }\n\n        queueHead = next.next;\n        next.next = null;\n        worker.call(context, next.value, next.worked);\n\n        if (queueTail === null) {\n          self.empty();\n        }\n      } else {\n        _running--;\n      }\n    } else if (--_running === 0) {\n      self.drain();\n    }\n  }\n\n  function kill() {\n    queueHead = null;\n    queueTail = null;\n    self.drain = noop;\n  }\n\n  function killAndDrain() {\n    queueHead = null;\n    queueTail = null;\n    self.drain();\n    self.drain = noop;\n  }\n\n  function error(handler) {\n    errorHandler = handler;\n  }\n}\n\nfunction noop() {}\n\nfunction Task() {\n  this.value = null;\n  this.callback = noop;\n  this.next = null;\n  this.release = noop;\n  this.context = null;\n  this.errorHandler = null;\n  var self = this;\n\n  this.worked = function worked(err, result) {\n    var callback = self.callback;\n    var errorHandler = self.errorHandler;\n    var val = self.value;\n    self.value = null;\n    self.callback = noop;\n\n    if (self.errorHandler) {\n      errorHandler(err, val);\n    }\n\n    callback.call(self.context, err, result);\n    self.release(self);\n  };\n}\n\nfunction queueAsPromised(context, worker, concurrency) {\n  if (typeof context === 'function') {\n    concurrency = worker;\n    worker = context;\n    context = null;\n  }\n\n  function asyncWrapper(arg, cb) {\n    worker.call(this, arg).then(function (res) {\n      cb(null, res);\n    }, cb);\n  }\n\n  var queue = fastqueue(context, asyncWrapper, concurrency);\n  var pushCb = queue.push;\n  var unshiftCb = queue.unshift;\n  queue.push = push;\n  queue.unshift = unshift;\n  queue.drained = drained;\n  return queue;\n\n  function push(value) {\n    var p = new Promise(function (resolve, reject) {\n      pushCb(value, function (err, result) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(result);\n      });\n    }); // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n\n    p.catch(noop);\n    return p;\n  }\n\n  function unshift(value) {\n    var p = new Promise(function (resolve, reject) {\n      unshiftCb(value, function (err, result) {\n        if (err) {\n          reject(err);\n          return;\n        }\n\n        resolve(result);\n      });\n    }); // Let's fork the promise chain to\n    // make the error bubble up to the user but\n    // not lead to a unhandledRejection\n\n    p.catch(noop);\n    return p;\n  }\n\n  function drained() {\n    var previousDrain = queue.drain;\n    var p = new Promise(function (resolve) {\n      queue.drain = function () {\n        previousDrain();\n        resolve();\n      };\n    });\n    return p;\n  }\n}\n\nmodule.exports = fastqueue;\nmodule.exports.promise = queueAsPromised;","map":{"version":3,"sources":["C:/Users/Valen/OneDrive/Documentos/Proyecto AWS/FrontServerless/node_modules/fastq/queue.js"],"names":["reusify","require","fastqueue","context","worker","concurrency","Error","cache","Task","queueHead","queueTail","_running","errorHandler","self","push","drain","noop","saturated","pause","paused","running","resume","idle","length","getQueue","unshift","empty","kill","killAndDrain","error","current","counter","next","tasks","value","i","release","done","get","callback","call","worked","holder","handler","err","result","val","queueAsPromised","asyncWrapper","arg","cb","then","res","queue","pushCb","unshiftCb","drained","p","Promise","resolve","reject","catch","previousDrain","module","exports","promise"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n/* eslint-disable no-var */\r\n\r\nvar reusify = require('reusify')\r\n\r\nfunction fastqueue (context, worker, concurrency) {\r\n  if (typeof context === 'function') {\r\n    concurrency = worker\r\n    worker = context\r\n    context = null\r\n  }\r\n\r\n  if (concurrency < 1) {\r\n    throw new Error('fastqueue concurrency must be greater than 1')\r\n  }\r\n\r\n  var cache = reusify(Task)\r\n  var queueHead = null\r\n  var queueTail = null\r\n  var _running = 0\r\n  var errorHandler = null\r\n\r\n  var self = {\r\n    push: push,\r\n    drain: noop,\r\n    saturated: noop,\r\n    pause: pause,\r\n    paused: false,\r\n    concurrency: concurrency,\r\n    running: running,\r\n    resume: resume,\r\n    idle: idle,\r\n    length: length,\r\n    getQueue: getQueue,\r\n    unshift: unshift,\r\n    empty: noop,\r\n    kill: kill,\r\n    killAndDrain: killAndDrain,\r\n    error: error\r\n  }\r\n\r\n  return self\r\n\r\n  function running () {\r\n    return _running\r\n  }\r\n\r\n  function pause () {\r\n    self.paused = true\r\n  }\r\n\r\n  function length () {\r\n    var current = queueHead\r\n    var counter = 0\r\n\r\n    while (current) {\r\n      current = current.next\r\n      counter++\r\n    }\r\n\r\n    return counter\r\n  }\r\n\r\n  function getQueue () {\r\n    var current = queueHead\r\n    var tasks = []\r\n\r\n    while (current) {\r\n      tasks.push(current.value)\r\n      current = current.next\r\n    }\r\n\r\n    return tasks\r\n  }\r\n\r\n  function resume () {\r\n    if (!self.paused) return\r\n    self.paused = false\r\n    for (var i = 0; i < self.concurrency; i++) {\r\n      _running++\r\n      release()\r\n    }\r\n  }\r\n\r\n  function idle () {\r\n    return _running === 0 && self.length() === 0\r\n  }\r\n\r\n  function push (value, done) {\r\n    var current = cache.get()\r\n\r\n    current.context = context\r\n    current.release = release\r\n    current.value = value\r\n    current.callback = done || noop\r\n    current.errorHandler = errorHandler\r\n\r\n    if (_running === self.concurrency || self.paused) {\r\n      if (queueTail) {\r\n        queueTail.next = current\r\n        queueTail = current\r\n      } else {\r\n        queueHead = current\r\n        queueTail = current\r\n        self.saturated()\r\n      }\r\n    } else {\r\n      _running++\r\n      worker.call(context, current.value, current.worked)\r\n    }\r\n  }\r\n\r\n  function unshift (value, done) {\r\n    var current = cache.get()\r\n\r\n    current.context = context\r\n    current.release = release\r\n    current.value = value\r\n    current.callback = done || noop\r\n\r\n    if (_running === self.concurrency || self.paused) {\r\n      if (queueHead) {\r\n        current.next = queueHead\r\n        queueHead = current\r\n      } else {\r\n        queueHead = current\r\n        queueTail = current\r\n        self.saturated()\r\n      }\r\n    } else {\r\n      _running++\r\n      worker.call(context, current.value, current.worked)\r\n    }\r\n  }\r\n\r\n  function release (holder) {\r\n    if (holder) {\r\n      cache.release(holder)\r\n    }\r\n    var next = queueHead\r\n    if (next) {\r\n      if (!self.paused) {\r\n        if (queueTail === queueHead) {\r\n          queueTail = null\r\n        }\r\n        queueHead = next.next\r\n        next.next = null\r\n        worker.call(context, next.value, next.worked)\r\n        if (queueTail === null) {\r\n          self.empty()\r\n        }\r\n      } else {\r\n        _running--\r\n      }\r\n    } else if (--_running === 0) {\r\n      self.drain()\r\n    }\r\n  }\r\n\r\n  function kill () {\r\n    queueHead = null\r\n    queueTail = null\r\n    self.drain = noop\r\n  }\r\n\r\n  function killAndDrain () {\r\n    queueHead = null\r\n    queueTail = null\r\n    self.drain()\r\n    self.drain = noop\r\n  }\r\n\r\n  function error (handler) {\r\n    errorHandler = handler\r\n  }\r\n}\r\n\r\nfunction noop () {}\r\n\r\nfunction Task () {\r\n  this.value = null\r\n  this.callback = noop\r\n  this.next = null\r\n  this.release = noop\r\n  this.context = null\r\n  this.errorHandler = null\r\n\r\n  var self = this\r\n\r\n  this.worked = function worked (err, result) {\r\n    var callback = self.callback\r\n    var errorHandler = self.errorHandler\r\n    var val = self.value\r\n    self.value = null\r\n    self.callback = noop\r\n    if (self.errorHandler) {\r\n      errorHandler(err, val)\r\n    }\r\n    callback.call(self.context, err, result)\r\n    self.release(self)\r\n  }\r\n}\r\n\r\nfunction queueAsPromised (context, worker, concurrency) {\r\n  if (typeof context === 'function') {\r\n    concurrency = worker\r\n    worker = context\r\n    context = null\r\n  }\r\n\r\n  function asyncWrapper (arg, cb) {\r\n    worker.call(this, arg)\r\n      .then(function (res) {\r\n        cb(null, res)\r\n      }, cb)\r\n  }\r\n\r\n  var queue = fastqueue(context, asyncWrapper, concurrency)\r\n\r\n  var pushCb = queue.push\r\n  var unshiftCb = queue.unshift\r\n\r\n  queue.push = push\r\n  queue.unshift = unshift\r\n  queue.drained = drained\r\n\r\n  return queue\r\n\r\n  function push (value) {\r\n    var p = new Promise(function (resolve, reject) {\r\n      pushCb(value, function (err, result) {\r\n        if (err) {\r\n          reject(err)\r\n          return\r\n        }\r\n        resolve(result)\r\n      })\r\n    })\r\n\r\n    // Let's fork the promise chain to\r\n    // make the error bubble up to the user but\r\n    // not lead to a unhandledRejection\r\n    p.catch(noop)\r\n\r\n    return p\r\n  }\r\n\r\n  function unshift (value) {\r\n    var p = new Promise(function (resolve, reject) {\r\n      unshiftCb(value, function (err, result) {\r\n        if (err) {\r\n          reject(err)\r\n          return\r\n        }\r\n        resolve(result)\r\n      })\r\n    })\r\n\r\n    // Let's fork the promise chain to\r\n    // make the error bubble up to the user but\r\n    // not lead to a unhandledRejection\r\n    p.catch(noop)\r\n\r\n    return p\r\n  }\r\n\r\n  function drained () {\r\n    var previousDrain = queue.drain\r\n\r\n    var p = new Promise(function (resolve) {\r\n      queue.drain = function () {\r\n        previousDrain()\r\n        resolve()\r\n      }\r\n    })\r\n\r\n    return p\r\n  }\r\n}\r\n\r\nmodule.exports = fastqueue\r\nmodule.exports.promise = queueAsPromised\r\n"]},"metadata":{},"sourceType":"script"}