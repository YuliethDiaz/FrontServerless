{"ast":null,"code":"'use strict';\n\nconst SINGLE_QUOTE = \"'\".charCodeAt(0);\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0);\nconst BACKSLASH = '\\\\'.charCodeAt(0);\nconst SLASH = '/'.charCodeAt(0);\nconst NEWLINE = '\\n'.charCodeAt(0);\nconst SPACE = ' '.charCodeAt(0);\nconst FEED = '\\f'.charCodeAt(0);\nconst TAB = '\\t'.charCodeAt(0);\nconst CR = '\\r'.charCodeAt(0);\nconst OPEN_SQUARE = '['.charCodeAt(0);\nconst CLOSE_SQUARE = ']'.charCodeAt(0);\nconst OPEN_PARENTHESES = '('.charCodeAt(0);\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0);\nconst OPEN_CURLY = '{'.charCodeAt(0);\nconst CLOSE_CURLY = '}'.charCodeAt(0);\nconst SEMICOLON = ';'.charCodeAt(0);\nconst ASTERISK = '*'.charCodeAt(0);\nconst COLON = ':'.charCodeAt(0);\nconst AT = '@'.charCodeAt(0);\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/;\nconst RE_HEX_ESCAPE = /[\\da-f]/i;\n\nmodule.exports = function tokenizer(input, options = {}) {\n  let css = input.css.valueOf();\n  let ignore = options.ignoreErrors;\n  let code, next, quote, content, escape;\n  let escaped, escapePos, prev, n, currentToken;\n  let length = css.length;\n  let pos = 0;\n  let buffer = [];\n  let returned = [];\n\n  function position() {\n    return pos;\n  }\n\n  function unclosed(what) {\n    throw input.error('Unclosed ' + what, pos);\n  }\n\n  function endOfFile() {\n    return returned.length === 0 && pos >= length;\n  }\n\n  function nextToken(opts) {\n    if (returned.length) return returned.pop();\n    if (pos >= length) return;\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n    code = css.charCodeAt(pos);\n\n    switch (code) {\n      case NEWLINE:\n      case SPACE:\n      case TAB:\n      case CR:\n      case FEED:\n        {\n          next = pos;\n\n          do {\n            next += 1;\n            code = css.charCodeAt(next);\n          } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n\n          currentToken = ['space', css.slice(pos, next)];\n          pos = next - 1;\n          break;\n        }\n\n      case OPEN_SQUARE:\n      case CLOSE_SQUARE:\n      case OPEN_CURLY:\n      case CLOSE_CURLY:\n      case COLON:\n      case SEMICOLON:\n      case CLOSE_PARENTHESES:\n        {\n          let controlChar = String.fromCharCode(code);\n          currentToken = [controlChar, controlChar, pos];\n          break;\n        }\n\n      case OPEN_PARENTHESES:\n        {\n          prev = buffer.length ? buffer.pop()[1] : '';\n          n = css.charCodeAt(pos + 1);\n\n          if (prev === 'url' && n !== SINGLE_QUOTE && n !== DOUBLE_QUOTE && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {\n            next = pos;\n\n            do {\n              escaped = false;\n              next = css.indexOf(')', next + 1);\n\n              if (next === -1) {\n                if (ignore || ignoreUnclosed) {\n                  next = pos;\n                  break;\n                } else {\n                  unclosed('bracket');\n                }\n              }\n\n              escapePos = next;\n\n              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n                escapePos -= 1;\n                escaped = !escaped;\n              }\n            } while (escaped);\n\n            currentToken = ['brackets', css.slice(pos, next + 1), pos, next];\n            pos = next;\n          } else {\n            next = css.indexOf(')', pos + 1);\n            content = css.slice(pos, next + 1);\n\n            if (next === -1 || RE_BAD_BRACKET.test(content)) {\n              currentToken = ['(', '(', pos];\n            } else {\n              currentToken = ['brackets', content, pos, next];\n              pos = next;\n            }\n          }\n\n          break;\n        }\n\n      case SINGLE_QUOTE:\n      case DOUBLE_QUOTE:\n        {\n          quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n          next = pos;\n\n          do {\n            escaped = false;\n            next = css.indexOf(quote, next + 1);\n\n            if (next === -1) {\n              if (ignore || ignoreUnclosed) {\n                next = pos + 1;\n                break;\n              } else {\n                unclosed('string');\n              }\n            }\n\n            escapePos = next;\n\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\n              escapePos -= 1;\n              escaped = !escaped;\n            }\n          } while (escaped);\n\n          currentToken = ['string', css.slice(pos, next + 1), pos, next];\n          pos = next;\n          break;\n        }\n\n      case AT:\n        {\n          RE_AT_END.lastIndex = pos + 1;\n          RE_AT_END.test(css);\n\n          if (RE_AT_END.lastIndex === 0) {\n            next = css.length - 1;\n          } else {\n            next = RE_AT_END.lastIndex - 2;\n          }\n\n          currentToken = ['at-word', css.slice(pos, next + 1), pos, next];\n          pos = next;\n          break;\n        }\n\n      case BACKSLASH:\n        {\n          next = pos;\n          escape = true;\n\n          while (css.charCodeAt(next + 1) === BACKSLASH) {\n            next += 1;\n            escape = !escape;\n          }\n\n          code = css.charCodeAt(next + 1);\n\n          if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n            next += 1;\n\n            if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n              while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\n                next += 1;\n              }\n\n              if (css.charCodeAt(next + 1) === SPACE) {\n                next += 1;\n              }\n            }\n          }\n\n          currentToken = ['word', css.slice(pos, next + 1), pos, next];\n          pos = next;\n          break;\n        }\n\n      default:\n        {\n          if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n            next = css.indexOf('*/', pos + 2) + 1;\n\n            if (next === 0) {\n              if (ignore || ignoreUnclosed) {\n                next = css.length;\n              } else {\n                unclosed('comment');\n              }\n            }\n\n            currentToken = ['comment', css.slice(pos, next + 1), pos, next];\n            pos = next;\n          } else {\n            RE_WORD_END.lastIndex = pos + 1;\n            RE_WORD_END.test(css);\n\n            if (RE_WORD_END.lastIndex === 0) {\n              next = css.length - 1;\n            } else {\n              next = RE_WORD_END.lastIndex - 2;\n            }\n\n            currentToken = ['word', css.slice(pos, next + 1), pos, next];\n            buffer.push(currentToken);\n            pos = next;\n          }\n\n          break;\n        }\n    }\n\n    pos++;\n    return currentToken;\n  }\n\n  function back(token) {\n    returned.push(token);\n  }\n\n  return {\n    back,\n    nextToken,\n    endOfFile,\n    position\n  };\n};","map":{"version":3,"sources":["C:/Users/Valen/OneDrive/Documentos/Proyecto AWS/FrontServerless/node_modules/postcss/lib/tokenize.js"],"names":["SINGLE_QUOTE","charCodeAt","DOUBLE_QUOTE","BACKSLASH","SLASH","NEWLINE","SPACE","FEED","TAB","CR","OPEN_SQUARE","CLOSE_SQUARE","OPEN_PARENTHESES","CLOSE_PARENTHESES","OPEN_CURLY","CLOSE_CURLY","SEMICOLON","ASTERISK","COLON","AT","RE_AT_END","RE_WORD_END","RE_BAD_BRACKET","RE_HEX_ESCAPE","module","exports","tokenizer","input","options","css","valueOf","ignore","ignoreErrors","code","next","quote","content","escape","escaped","escapePos","prev","n","currentToken","length","pos","buffer","returned","position","unclosed","what","error","endOfFile","nextToken","opts","pop","ignoreUnclosed","slice","controlChar","String","fromCharCode","indexOf","test","lastIndex","charAt","push","back","token"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst SINGLE_QUOTE = \"'\".charCodeAt(0)\r\nconst DOUBLE_QUOTE = '\"'.charCodeAt(0)\r\nconst BACKSLASH = '\\\\'.charCodeAt(0)\r\nconst SLASH = '/'.charCodeAt(0)\r\nconst NEWLINE = '\\n'.charCodeAt(0)\r\nconst SPACE = ' '.charCodeAt(0)\r\nconst FEED = '\\f'.charCodeAt(0)\r\nconst TAB = '\\t'.charCodeAt(0)\r\nconst CR = '\\r'.charCodeAt(0)\r\nconst OPEN_SQUARE = '['.charCodeAt(0)\r\nconst CLOSE_SQUARE = ']'.charCodeAt(0)\r\nconst OPEN_PARENTHESES = '('.charCodeAt(0)\r\nconst CLOSE_PARENTHESES = ')'.charCodeAt(0)\r\nconst OPEN_CURLY = '{'.charCodeAt(0)\r\nconst CLOSE_CURLY = '}'.charCodeAt(0)\r\nconst SEMICOLON = ';'.charCodeAt(0)\r\nconst ASTERISK = '*'.charCodeAt(0)\r\nconst COLON = ':'.charCodeAt(0)\r\nconst AT = '@'.charCodeAt(0)\r\n\r\nconst RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g\r\nconst RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g\r\nconst RE_BAD_BRACKET = /.[\\n\"'(/\\\\]/\r\nconst RE_HEX_ESCAPE = /[\\da-f]/i\r\n\r\nmodule.exports = function tokenizer(input, options = {}) {\r\n  let css = input.css.valueOf()\r\n  let ignore = options.ignoreErrors\r\n\r\n  let code, next, quote, content, escape\r\n  let escaped, escapePos, prev, n, currentToken\r\n\r\n  let length = css.length\r\n  let pos = 0\r\n  let buffer = []\r\n  let returned = []\r\n\r\n  function position() {\r\n    return pos\r\n  }\r\n\r\n  function unclosed(what) {\r\n    throw input.error('Unclosed ' + what, pos)\r\n  }\r\n\r\n  function endOfFile() {\r\n    return returned.length === 0 && pos >= length\r\n  }\r\n\r\n  function nextToken(opts) {\r\n    if (returned.length) return returned.pop()\r\n    if (pos >= length) return\r\n\r\n    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false\r\n\r\n    code = css.charCodeAt(pos)\r\n\r\n    switch (code) {\r\n      case NEWLINE:\r\n      case SPACE:\r\n      case TAB:\r\n      case CR:\r\n      case FEED: {\r\n        next = pos\r\n        do {\r\n          next += 1\r\n          code = css.charCodeAt(next)\r\n        } while (\r\n          code === SPACE ||\r\n          code === NEWLINE ||\r\n          code === TAB ||\r\n          code === CR ||\r\n          code === FEED\r\n        )\r\n\r\n        currentToken = ['space', css.slice(pos, next)]\r\n        pos = next - 1\r\n        break\r\n      }\r\n\r\n      case OPEN_SQUARE:\r\n      case CLOSE_SQUARE:\r\n      case OPEN_CURLY:\r\n      case CLOSE_CURLY:\r\n      case COLON:\r\n      case SEMICOLON:\r\n      case CLOSE_PARENTHESES: {\r\n        let controlChar = String.fromCharCode(code)\r\n        currentToken = [controlChar, controlChar, pos]\r\n        break\r\n      }\r\n\r\n      case OPEN_PARENTHESES: {\r\n        prev = buffer.length ? buffer.pop()[1] : ''\r\n        n = css.charCodeAt(pos + 1)\r\n        if (\r\n          prev === 'url' &&\r\n          n !== SINGLE_QUOTE &&\r\n          n !== DOUBLE_QUOTE &&\r\n          n !== SPACE &&\r\n          n !== NEWLINE &&\r\n          n !== TAB &&\r\n          n !== FEED &&\r\n          n !== CR\r\n        ) {\r\n          next = pos\r\n          do {\r\n            escaped = false\r\n            next = css.indexOf(')', next + 1)\r\n            if (next === -1) {\r\n              if (ignore || ignoreUnclosed) {\r\n                next = pos\r\n                break\r\n              } else {\r\n                unclosed('bracket')\r\n              }\r\n            }\r\n            escapePos = next\r\n            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\r\n              escapePos -= 1\r\n              escaped = !escaped\r\n            }\r\n          } while (escaped)\r\n\r\n          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]\r\n\r\n          pos = next\r\n        } else {\r\n          next = css.indexOf(')', pos + 1)\r\n          content = css.slice(pos, next + 1)\r\n\r\n          if (next === -1 || RE_BAD_BRACKET.test(content)) {\r\n            currentToken = ['(', '(', pos]\r\n          } else {\r\n            currentToken = ['brackets', content, pos, next]\r\n            pos = next\r\n          }\r\n        }\r\n\r\n        break\r\n      }\r\n\r\n      case SINGLE_QUOTE:\r\n      case DOUBLE_QUOTE: {\r\n        quote = code === SINGLE_QUOTE ? \"'\" : '\"'\r\n        next = pos\r\n        do {\r\n          escaped = false\r\n          next = css.indexOf(quote, next + 1)\r\n          if (next === -1) {\r\n            if (ignore || ignoreUnclosed) {\r\n              next = pos + 1\r\n              break\r\n            } else {\r\n              unclosed('string')\r\n            }\r\n          }\r\n          escapePos = next\r\n          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {\r\n            escapePos -= 1\r\n            escaped = !escaped\r\n          }\r\n        } while (escaped)\r\n\r\n        currentToken = ['string', css.slice(pos, next + 1), pos, next]\r\n        pos = next\r\n        break\r\n      }\r\n\r\n      case AT: {\r\n        RE_AT_END.lastIndex = pos + 1\r\n        RE_AT_END.test(css)\r\n        if (RE_AT_END.lastIndex === 0) {\r\n          next = css.length - 1\r\n        } else {\r\n          next = RE_AT_END.lastIndex - 2\r\n        }\r\n\r\n        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]\r\n\r\n        pos = next\r\n        break\r\n      }\r\n\r\n      case BACKSLASH: {\r\n        next = pos\r\n        escape = true\r\n        while (css.charCodeAt(next + 1) === BACKSLASH) {\r\n          next += 1\r\n          escape = !escape\r\n        }\r\n        code = css.charCodeAt(next + 1)\r\n        if (\r\n          escape &&\r\n          code !== SLASH &&\r\n          code !== SPACE &&\r\n          code !== NEWLINE &&\r\n          code !== TAB &&\r\n          code !== CR &&\r\n          code !== FEED\r\n        ) {\r\n          next += 1\r\n          if (RE_HEX_ESCAPE.test(css.charAt(next))) {\r\n            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {\r\n              next += 1\r\n            }\r\n            if (css.charCodeAt(next + 1) === SPACE) {\r\n              next += 1\r\n            }\r\n          }\r\n        }\r\n\r\n        currentToken = ['word', css.slice(pos, next + 1), pos, next]\r\n\r\n        pos = next\r\n        break\r\n      }\r\n\r\n      default: {\r\n        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\r\n          next = css.indexOf('*/', pos + 2) + 1\r\n          if (next === 0) {\r\n            if (ignore || ignoreUnclosed) {\r\n              next = css.length\r\n            } else {\r\n              unclosed('comment')\r\n            }\r\n          }\r\n\r\n          currentToken = ['comment', css.slice(pos, next + 1), pos, next]\r\n          pos = next\r\n        } else {\r\n          RE_WORD_END.lastIndex = pos + 1\r\n          RE_WORD_END.test(css)\r\n          if (RE_WORD_END.lastIndex === 0) {\r\n            next = css.length - 1\r\n          } else {\r\n            next = RE_WORD_END.lastIndex - 2\r\n          }\r\n\r\n          currentToken = ['word', css.slice(pos, next + 1), pos, next]\r\n          buffer.push(currentToken)\r\n          pos = next\r\n        }\r\n\r\n        break\r\n      }\r\n    }\r\n\r\n    pos++\r\n    return currentToken\r\n  }\r\n\r\n  function back(token) {\r\n    returned.push(token)\r\n  }\r\n\r\n  return {\r\n    back,\r\n    nextToken,\r\n    endOfFile,\r\n    position\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}