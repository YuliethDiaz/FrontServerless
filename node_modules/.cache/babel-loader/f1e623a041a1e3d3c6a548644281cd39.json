{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = setupWatchingContext;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _tmp = _interopRequireDefault(require(\"tmp\"));\n\nvar _chokidar = _interopRequireDefault(require(\"chokidar\"));\n\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\n\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\n\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\n\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\n\nvar _log = _interopRequireDefault(require(\"../../util/log\"));\n\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\n\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\n\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\n\nvar _setupContextUtils = require(\"./setupContextUtils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // This is used to trigger rebuilds. Just updating the timestamp\n// is significantly faster than actually writing to the file (10x).\n\n\nfunction touch(filename) {\n  let time = new Date();\n\n  try {\n    _fs.default.utimesSync(filename, time, time);\n  } catch (err) {\n    _fs.default.closeSync(_fs.default.openSync(filename, 'w'));\n  }\n}\n\nlet watchers = new WeakMap();\n\nfunction getWatcher(context) {\n  if (watchers.has(context)) {\n    return watchers.get(context);\n  }\n\n  return null;\n}\n\nfunction setWatcher(context, watcher) {\n  return watchers.set(context, watcher);\n}\n\nlet touchFiles = new WeakMap();\n\nfunction getTouchFile(context) {\n  if (touchFiles.has(context)) {\n    return touchFiles.get(context);\n  }\n\n  return null;\n}\n\nfunction setTouchFile(context, touchFile) {\n  return touchFiles.set(context, touchFile);\n}\n\nlet configPaths = new WeakMap();\n\nfunction getConfigPath(context, configOrPath) {\n  if (!configPaths.has(context)) {\n    configPaths.set(context, (0, _resolveConfigPath.default)(configOrPath));\n  }\n\n  return configPaths.get(context);\n}\n\nfunction rebootWatcher(context, configPath, configDependencies, candidateFiles) {\n  let touchFile = getTouchFile(context);\n\n  if (touchFile === null) {\n    touchFile = _tmp.default.fileSync().name;\n    setTouchFile(context, touchFile);\n    touch(touchFile);\n  }\n\n  let watcher = getWatcher(context);\n  Promise.resolve(watcher ? watcher.close() : null).then(() => {\n    _log.default.info(['Tailwind CSS is watching for changes...', 'https://tailwindcss.com/docs/just-in-time-mode#watch-mode-and-one-off-builds']);\n\n    watcher = _chokidar.default.watch([...candidateFiles, ...configDependencies], {\n      ignoreInitial: true,\n      awaitWriteFinish: process.platform === 'win32' ? {\n        stabilityThreshold: 50,\n        pollInterval: 10\n      } : false\n    });\n    setWatcher(context, watcher);\n    watcher.on('add', file => {\n      let changedFile = _path.default.resolve('.', file);\n\n      let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n      let extension = _path.default.extname(changedFile).slice(1);\n\n      context.changedContent.push({\n        content,\n        extension\n      });\n      touch(touchFile);\n    });\n    watcher.on('change', file => {\n      // If it was a config dependency, touch the config file to trigger a new context.\n      // This is not really that clean of a solution but it's the fastest, because we\n      // can do a very quick check on each build to see if the config has changed instead\n      // of having to get all of the module dependencies and check every timestamp each\n      // time.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      } else {\n        let changedFile = _path.default.resolve('.', file);\n\n        let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n        let extension = _path.default.extname(changedFile).slice(1);\n\n        context.changedContent.push({\n          content,\n          extension\n        });\n        touch(touchFile);\n      }\n    });\n    watcher.on('unlink', file => {\n      // Touch the config file if any of the dependencies are deleted.\n      if (configDependencies.has(file)) {\n        for (let dependency of configDependencies) {\n          delete require.cache[require.resolve(dependency)];\n        }\n\n        touch(configPath);\n      }\n    });\n  });\n}\n\nlet configPathCache = new _quickLru.default({\n  maxSize: 100\n});\nlet configDependenciesCache = new WeakMap();\n\nfunction getConfigDependencies(context) {\n  if (!configDependenciesCache.has(context)) {\n    configDependenciesCache.set(context, new Set());\n  }\n\n  return configDependenciesCache.get(context);\n}\n\nlet candidateFilesCache = new WeakMap();\n\nfunction getCandidateFiles(context, tailwindConfig) {\n  if (candidateFilesCache.has(context)) {\n    return candidateFilesCache.get(context);\n  }\n\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\n  return candidateFilesCache.set(context, candidateFiles).get(context);\n} // Get the config object based on a path\n\n\nfunction getTailwindConfig(configOrPath) {\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\n\n  if (userConfigPath !== null) {\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] = configPathCache.get(userConfigPath) || [];\n\n    let modified = _fs.default.statSync(userConfigPath).mtimeMs; // It hasn't changed (based on timestamp)\n\n\n    if (modified <= prevModified) {\n      return [prevConfig, userConfigPath, prevConfigHash, [userConfigPath]];\n    } // It has changed (based on timestamp), or first run\n\n\n    delete require.cache[userConfigPath];\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\n    let newHash = (0, _hashConfig.default)(newConfig);\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash]);\n    return [newConfig, userConfigPath, newHash, [userConfigPath]];\n  } // It's a plain object, not a path\n\n\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\n}\n\nfunction resolvedChangedContent(context, candidateFiles) {\n  var _context$tailwindConf, _context$tailwindConf2;\n\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\n    if (typeof content === 'string') {\n      return {\n        raw: content,\n        extension: 'html'\n      };\n    }\n\n    if (content instanceof RegExp) {\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\n    }\n\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\n  })).map(({\n    raw,\n    extension\n  }) => ({\n    content: raw,\n    extension\n  }));\n\n  for (let changedFile of resolveChangedFiles(context, candidateFiles)) {\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\n\n    let extension = _path.default.extname(changedFile).slice(1);\n\n    changedContent.push({\n      content,\n      extension\n    });\n  }\n\n  return changedContent;\n}\n\nlet scannedContentCache = new WeakMap();\n\nfunction resolveChangedFiles(context, candidateFiles) {\n  let changedFiles = new Set(); // If we're not set up and watching files ourselves, we need to do\n  // the work of grabbing all of the template files for candidate\n  // detection.\n\n  if (!scannedContentCache.has(context)) {\n    let files = _fastGlob.default.sync(candidateFiles);\n\n    for (let file of files) {\n      changedFiles.add(file);\n    }\n\n    scannedContentCache.set(context, true);\n  }\n\n  return changedFiles;\n} // DISABLE_TOUCH = FALSE\n// Retrieve an existing context from cache if possible (since contexts are unique per\n// source path), or set up a new one (including setting up watchers and registering\n// plugins) then return it\n\n\nfunction setupWatchingContext(configOrPath) {\n  return ({\n    tailwindDirectives,\n    registerDependency\n  }) => {\n    return (root, result) => {\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\n      // to be dependencies of the context. Can reuse the context even if they change.\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\n      // in another file since independent sources are effectively isolated.\n\n      if (tailwindDirectives.size > 0) {\n        // Add current css file as a context dependencies.\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\n\n        for (let message of result.messages) {\n          if (message.type === 'dependency') {\n            contextDependencies.add(message.file);\n          }\n        }\n      }\n\n      let [context, isNewContext] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\n      let contextConfigDependencies = getConfigDependencies(context);\n\n      for (let file of configDependencies) {\n        registerDependency({\n          type: 'dependency',\n          file\n        });\n      }\n\n      context.disposables.push(oldContext => {\n        let watcher = getWatcher(oldContext);\n\n        if (watcher !== null) {\n          watcher.close();\n        }\n      });\n      let configPath = getConfigPath(context, configOrPath);\n\n      if (configPath !== null) {\n        for (let dependency of (0, _getModuleDependencies.default)(configPath)) {\n          if (dependency.file === configPath) {\n            continue;\n          }\n\n          contextConfigDependencies.add(dependency.file);\n        }\n      }\n\n      if (isNewContext) {\n        rebootWatcher(context, configPath, contextConfigDependencies, candidateFiles);\n      } // Register our temp file as a dependency ‚Äî we write to this file\n      // to trigger rebuilds.\n\n\n      let touchFile = getTouchFile(context);\n\n      if (touchFile) {\n        registerDependency({\n          type: 'dependency',\n          file: touchFile\n        });\n      }\n\n      if (tailwindDirectives.size > 0) {\n        for (let changedContent of resolvedChangedContent(context, candidateFiles)) {\n          context.changedContent.push(changedContent);\n        }\n      }\n\n      return context;\n    };\n  };\n}","map":{"version":3,"sources":["C:/Users/Valen/OneDrive/Documentos/Proyecto AWS/FrontServerless/node_modules/tailwindcss/lib/jit/lib/setupWatchingContext.js"],"names":["Object","defineProperty","exports","value","default","setupWatchingContext","_fs","_interopRequireDefault","require","_path","_tmp","_chokidar","_fastGlob","_quickLru","_normalizePath","_hashConfig","_log","_getModuleDependencies","_resolveConfig","_resolveConfigPath","_setupContextUtils","obj","__esModule","touch","filename","time","Date","utimesSync","err","closeSync","openSync","watchers","WeakMap","getWatcher","context","has","get","setWatcher","watcher","set","touchFiles","getTouchFile","setTouchFile","touchFile","configPaths","getConfigPath","configOrPath","rebootWatcher","configPath","configDependencies","candidateFiles","fileSync","name","Promise","resolve","close","then","info","watch","ignoreInitial","awaitWriteFinish","process","platform","stabilityThreshold","pollInterval","on","file","changedFile","content","readFileSync","extension","extname","slice","changedContent","push","dependency","cache","configPathCache","maxSize","configDependenciesCache","getConfigDependencies","Set","candidateFilesCache","getCandidateFiles","tailwindConfig","purgeContent","Array","isArray","purge","filter","item","map","purgePath","getTailwindConfig","userConfigPath","prevConfig","prevModified","Infinity","prevConfigHash","modified","statSync","mtimeMs","newConfig","newHash","config","undefined","resolvedChangedContent","_context$tailwindConf","_context$tailwindConf2","raw","concat","safelist","RegExp","Error","resolveChangedFiles","scannedContentCache","changedFiles","files","sync","add","tailwindDirectives","registerDependency","root","result","tailwindConfigHash","contextDependencies","size","opts","from","message","messages","type","isNewContext","getContext","contextConfigDependencies","disposables","oldContext"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\nexports.default = setupWatchingContext;\r\n\r\nvar _fs = _interopRequireDefault(require(\"fs\"));\r\n\r\nvar _path = _interopRequireDefault(require(\"path\"));\r\n\r\nvar _tmp = _interopRequireDefault(require(\"tmp\"));\r\n\r\nvar _chokidar = _interopRequireDefault(require(\"chokidar\"));\r\n\r\nvar _fastGlob = _interopRequireDefault(require(\"fast-glob\"));\r\n\r\nvar _quickLru = _interopRequireDefault(require(\"quick-lru\"));\r\n\r\nvar _normalizePath = _interopRequireDefault(require(\"normalize-path\"));\r\n\r\nvar _hashConfig = _interopRequireDefault(require(\"../../util/hashConfig\"));\r\n\r\nvar _log = _interopRequireDefault(require(\"../../util/log\"));\r\n\r\nvar _getModuleDependencies = _interopRequireDefault(require(\"../../lib/getModuleDependencies\"));\r\n\r\nvar _resolveConfig = _interopRequireDefault(require(\"../../../resolveConfig\"));\r\n\r\nvar _resolveConfigPath = _interopRequireDefault(require(\"../../util/resolveConfigPath\"));\r\n\r\nvar _setupContextUtils = require(\"./setupContextUtils\");\r\n\r\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\r\n\r\n// This is used to trigger rebuilds. Just updating the timestamp\r\n// is significantly faster than actually writing to the file (10x).\r\nfunction touch(filename) {\r\n  let time = new Date();\r\n\r\n  try {\r\n    _fs.default.utimesSync(filename, time, time);\r\n  } catch (err) {\r\n    _fs.default.closeSync(_fs.default.openSync(filename, 'w'));\r\n  }\r\n}\r\n\r\nlet watchers = new WeakMap();\r\n\r\nfunction getWatcher(context) {\r\n  if (watchers.has(context)) {\r\n    return watchers.get(context);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction setWatcher(context, watcher) {\r\n  return watchers.set(context, watcher);\r\n}\r\n\r\nlet touchFiles = new WeakMap();\r\n\r\nfunction getTouchFile(context) {\r\n  if (touchFiles.has(context)) {\r\n    return touchFiles.get(context);\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nfunction setTouchFile(context, touchFile) {\r\n  return touchFiles.set(context, touchFile);\r\n}\r\n\r\nlet configPaths = new WeakMap();\r\n\r\nfunction getConfigPath(context, configOrPath) {\r\n  if (!configPaths.has(context)) {\r\n    configPaths.set(context, (0, _resolveConfigPath.default)(configOrPath));\r\n  }\r\n\r\n  return configPaths.get(context);\r\n}\r\n\r\nfunction rebootWatcher(context, configPath, configDependencies, candidateFiles) {\r\n  let touchFile = getTouchFile(context);\r\n\r\n  if (touchFile === null) {\r\n    touchFile = _tmp.default.fileSync().name;\r\n    setTouchFile(context, touchFile);\r\n    touch(touchFile);\r\n  }\r\n\r\n  let watcher = getWatcher(context);\r\n  Promise.resolve(watcher ? watcher.close() : null).then(() => {\r\n    _log.default.info(['Tailwind CSS is watching for changes...', 'https://tailwindcss.com/docs/just-in-time-mode#watch-mode-and-one-off-builds']);\r\n\r\n    watcher = _chokidar.default.watch([...candidateFiles, ...configDependencies], {\r\n      ignoreInitial: true,\r\n      awaitWriteFinish: process.platform === 'win32' ? {\r\n        stabilityThreshold: 50,\r\n        pollInterval: 10\r\n      } : false\r\n    });\r\n    setWatcher(context, watcher);\r\n    watcher.on('add', file => {\r\n      let changedFile = _path.default.resolve('.', file);\r\n\r\n      let content = _fs.default.readFileSync(changedFile, 'utf8');\r\n\r\n      let extension = _path.default.extname(changedFile).slice(1);\r\n\r\n      context.changedContent.push({\r\n        content,\r\n        extension\r\n      });\r\n      touch(touchFile);\r\n    });\r\n    watcher.on('change', file => {\r\n      // If it was a config dependency, touch the config file to trigger a new context.\r\n      // This is not really that clean of a solution but it's the fastest, because we\r\n      // can do a very quick check on each build to see if the config has changed instead\r\n      // of having to get all of the module dependencies and check every timestamp each\r\n      // time.\r\n      if (configDependencies.has(file)) {\r\n        for (let dependency of configDependencies) {\r\n          delete require.cache[require.resolve(dependency)];\r\n        }\r\n\r\n        touch(configPath);\r\n      } else {\r\n        let changedFile = _path.default.resolve('.', file);\r\n\r\n        let content = _fs.default.readFileSync(changedFile, 'utf8');\r\n\r\n        let extension = _path.default.extname(changedFile).slice(1);\r\n\r\n        context.changedContent.push({\r\n          content,\r\n          extension\r\n        });\r\n        touch(touchFile);\r\n      }\r\n    });\r\n    watcher.on('unlink', file => {\r\n      // Touch the config file if any of the dependencies are deleted.\r\n      if (configDependencies.has(file)) {\r\n        for (let dependency of configDependencies) {\r\n          delete require.cache[require.resolve(dependency)];\r\n        }\r\n\r\n        touch(configPath);\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\nlet configPathCache = new _quickLru.default({\r\n  maxSize: 100\r\n});\r\nlet configDependenciesCache = new WeakMap();\r\n\r\nfunction getConfigDependencies(context) {\r\n  if (!configDependenciesCache.has(context)) {\r\n    configDependenciesCache.set(context, new Set());\r\n  }\r\n\r\n  return configDependenciesCache.get(context);\r\n}\r\n\r\nlet candidateFilesCache = new WeakMap();\r\n\r\nfunction getCandidateFiles(context, tailwindConfig) {\r\n  if (candidateFilesCache.has(context)) {\r\n    return candidateFilesCache.get(context);\r\n  }\r\n\r\n  let purgeContent = Array.isArray(tailwindConfig.purge) ? tailwindConfig.purge : tailwindConfig.purge.content;\r\n  let candidateFiles = purgeContent.filter(item => typeof item === 'string').map(purgePath => (0, _normalizePath.default)(_path.default.resolve(purgePath)));\r\n  return candidateFilesCache.set(context, candidateFiles).get(context);\r\n} // Get the config object based on a path\r\n\r\n\r\nfunction getTailwindConfig(configOrPath) {\r\n  let userConfigPath = (0, _resolveConfigPath.default)(configOrPath);\r\n\r\n  if (userConfigPath !== null) {\r\n    let [prevConfig, prevModified = -Infinity, prevConfigHash] = configPathCache.get(userConfigPath) || [];\r\n\r\n    let modified = _fs.default.statSync(userConfigPath).mtimeMs; // It hasn't changed (based on timestamp)\r\n\r\n\r\n    if (modified <= prevModified) {\r\n      return [prevConfig, userConfigPath, prevConfigHash, [userConfigPath]];\r\n    } // It has changed (based on timestamp), or first run\r\n\r\n\r\n    delete require.cache[userConfigPath];\r\n    let newConfig = (0, _resolveConfig.default)(require(userConfigPath));\r\n    let newHash = (0, _hashConfig.default)(newConfig);\r\n    configPathCache.set(userConfigPath, [newConfig, modified, newHash]);\r\n    return [newConfig, userConfigPath, newHash, [userConfigPath]];\r\n  } // It's a plain object, not a path\r\n\r\n\r\n  let newConfig = (0, _resolveConfig.default)(configOrPath.config === undefined ? configOrPath : configOrPath.config);\r\n  return [newConfig, null, (0, _hashConfig.default)(newConfig), []];\r\n}\r\n\r\nfunction resolvedChangedContent(context, candidateFiles) {\r\n  var _context$tailwindConf, _context$tailwindConf2;\r\n\r\n  let changedContent = (Array.isArray(context.tailwindConfig.purge) ? context.tailwindConfig.purge : context.tailwindConfig.purge.content).filter(item => typeof item.raw === 'string').concat(((_context$tailwindConf = (_context$tailwindConf2 = context.tailwindConfig.purge) === null || _context$tailwindConf2 === void 0 ? void 0 : _context$tailwindConf2.safelist) !== null && _context$tailwindConf !== void 0 ? _context$tailwindConf : []).map(content => {\r\n    if (typeof content === 'string') {\r\n      return {\r\n        raw: content,\r\n        extension: 'html'\r\n      };\r\n    }\r\n\r\n    if (content instanceof RegExp) {\r\n      throw new Error(\"Values inside 'purge.safelist' can only be of type 'string', found 'regex'.\");\r\n    }\r\n\r\n    throw new Error(`Values inside 'purge.safelist' can only be of type 'string', found '${typeof content}'.`);\r\n  })).map(({\r\n    raw,\r\n    extension\r\n  }) => ({\r\n    content: raw,\r\n    extension\r\n  }));\r\n\r\n  for (let changedFile of resolveChangedFiles(context, candidateFiles)) {\r\n    let content = _fs.default.readFileSync(changedFile, 'utf8');\r\n\r\n    let extension = _path.default.extname(changedFile).slice(1);\r\n\r\n    changedContent.push({\r\n      content,\r\n      extension\r\n    });\r\n  }\r\n\r\n  return changedContent;\r\n}\r\n\r\nlet scannedContentCache = new WeakMap();\r\n\r\nfunction resolveChangedFiles(context, candidateFiles) {\r\n  let changedFiles = new Set(); // If we're not set up and watching files ourselves, we need to do\r\n  // the work of grabbing all of the template files for candidate\r\n  // detection.\r\n\r\n  if (!scannedContentCache.has(context)) {\r\n    let files = _fastGlob.default.sync(candidateFiles);\r\n\r\n    for (let file of files) {\r\n      changedFiles.add(file);\r\n    }\r\n\r\n    scannedContentCache.set(context, true);\r\n  }\r\n\r\n  return changedFiles;\r\n} // DISABLE_TOUCH = FALSE\r\n// Retrieve an existing context from cache if possible (since contexts are unique per\r\n// source path), or set up a new one (including setting up watchers and registering\r\n// plugins) then return it\r\n\r\n\r\nfunction setupWatchingContext(configOrPath) {\r\n  return ({\r\n    tailwindDirectives,\r\n    registerDependency\r\n  }) => {\r\n    return (root, result) => {\r\n      let [tailwindConfig, userConfigPath, tailwindConfigHash, configDependencies] = getTailwindConfig(configOrPath);\r\n      let contextDependencies = new Set(configDependencies); // If there are no @tailwind rules, we don't consider this CSS file or it's dependencies\r\n      // to be dependencies of the context. Can reuse the context even if they change.\r\n      // We may want to think about `@layer` being part of this trigger too, but it's tough\r\n      // because it's impossible for a layer in one file to end up in the actual @tailwind rule\r\n      // in another file since independent sources are effectively isolated.\r\n\r\n      if (tailwindDirectives.size > 0) {\r\n        // Add current css file as a context dependencies.\r\n        contextDependencies.add(result.opts.from); // Add all css @import dependencies as context dependencies.\r\n\r\n        for (let message of result.messages) {\r\n          if (message.type === 'dependency') {\r\n            contextDependencies.add(message.file);\r\n          }\r\n        }\r\n      }\r\n\r\n      let [context, isNewContext] = (0, _setupContextUtils.getContext)(tailwindDirectives, root, result, tailwindConfig, userConfigPath, tailwindConfigHash, contextDependencies);\r\n      let candidateFiles = getCandidateFiles(context, tailwindConfig);\r\n      let contextConfigDependencies = getConfigDependencies(context);\r\n\r\n      for (let file of configDependencies) {\r\n        registerDependency({\r\n          type: 'dependency',\r\n          file\r\n        });\r\n      }\r\n\r\n      context.disposables.push(oldContext => {\r\n        let watcher = getWatcher(oldContext);\r\n\r\n        if (watcher !== null) {\r\n          watcher.close();\r\n        }\r\n      });\r\n      let configPath = getConfigPath(context, configOrPath);\r\n\r\n      if (configPath !== null) {\r\n        for (let dependency of (0, _getModuleDependencies.default)(configPath)) {\r\n          if (dependency.file === configPath) {\r\n            continue;\r\n          }\r\n\r\n          contextConfigDependencies.add(dependency.file);\r\n        }\r\n      }\r\n\r\n      if (isNewContext) {\r\n        rebootWatcher(context, configPath, contextConfigDependencies, candidateFiles);\r\n      } // Register our temp file as a dependency ‚Äî we write to this file\r\n      // to trigger rebuilds.\r\n\r\n\r\n      let touchFile = getTouchFile(context);\r\n\r\n      if (touchFile) {\r\n        registerDependency({\r\n          type: 'dependency',\r\n          file: touchFile\r\n        });\r\n      }\r\n\r\n      if (tailwindDirectives.size > 0) {\r\n        for (let changedContent of resolvedChangedContent(context, candidateFiles)) {\r\n          context.changedContent.push(changedContent);\r\n        }\r\n      }\r\n\r\n      return context;\r\n    };\r\n  };\r\n}"]},"metadata":{},"sourceType":"script"}