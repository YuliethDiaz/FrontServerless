{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst braces = require('braces');\n\nconst picomatch = require('picomatch');\n\nconst utils = require('picomatch/lib/utils');\n\nconst isEmptyString = val => val === '' || val === './';\n/**\r\n * Returns an array of strings that match one or more glob patterns.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm(list, patterns[, options]);\r\n *\r\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {String|Array<string>} `list` List of strings to match.\r\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options)\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\n\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch(String(patterns[i]), { ...options,\n      onResult\n    }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n/**\r\n * Backwards compatibility\r\n */\n\n\nmicromatch.match = micromatch;\n/**\r\n * Returns a matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matcher(pattern[, options]);\r\n *\r\n * const isMatch = mm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options`\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\n\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `[options]` See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\r\n * Backwards compatibility\r\n */\n\n\nmicromatch.any = micromatch.isMatch;\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.not(list, patterns[, options]);\r\n *\r\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options,\n    onResult\n  });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n\n  return [...result];\n};\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var mm = require('micromatch');\r\n * // mm.contains(string, pattern[, options]);\r\n *\r\n * console.log(mm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(mm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\r\n * @api public\r\n */\n\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || str.startsWith('./') && str.slice(2).includes(pattern)) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options,\n    contains: true\n  });\n};\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matchKeys(object, patterns[, options]);\r\n *\r\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(mm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\n\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n\n  for (let key of keys) res[key] = obj[key];\n\n  return res;\n};\n/**\r\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.some(list, patterns[, options]);\r\n *\r\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\r\n * @api public\r\n */\n\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * Returns true if every string in the given `list` matches\r\n * any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.every(list, patterns[, options]);\r\n *\r\n * console.log(mm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\r\n * @api public\r\n */\n\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch(String(pattern), options);\n\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\r\n * Returns true if **all** of the given `patterns` match\r\n * the specified string.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.all(string, patterns[, options]);\r\n *\r\n * console.log(mm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\n\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\n};\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.capture(pattern, string[, options]);\r\n *\r\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `glob` Glob pattern to use for matching.\r\n * @param {String} `input` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\n\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils.isWindows(options);\n  let regex = picomatch.makeRe(String(glob), { ...options,\n    capture: true\n  });\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.makeRe(pattern[, options]);\r\n *\r\n * console.log(mm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\n\n\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\n/**\r\n * Scan a glob pattern to separate the pattern into segments. Used\r\n * by the [split](#split) method.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.scan(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\n\n\nmicromatch.scan = (...args) => picomatch.scan(...args);\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm(pattern[, options]);\r\n * ```\r\n * @param {String} `glob`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\r\n * @api public\r\n */\n\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces(String(pattern), options)) {\n      res.push(picomatch.parse(str, options));\n    }\n  }\n\n  return res;\n};\n/**\r\n * Process the given brace `pattern`.\r\n *\r\n * ```js\r\n * const { braces } = require('micromatch');\r\n * console.log(braces('foo/{a,b,c}/bar'));\r\n * //=> [ 'foo/(a|b|c)/bar' ]\r\n *\r\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\r\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\r\n * ```\r\n * @param {String} `pattern` String with brace pattern to process.\r\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\r\n * @return {Array}\r\n * @api public\r\n */\n\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n\n  if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n\n  return braces(pattern, options);\n};\n/**\r\n * Expand braces\r\n */\n\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options,\n    expand: true\n  });\n};\n/**\r\n * Expose micromatch\r\n */\n\n\nmodule.exports = micromatch;","map":{"version":3,"sources":["C:/Users/Valen/OneDrive/Documentos/Proyecto AWS/FrontServerless/node_modules/micromatch/index.js"],"names":["util","require","braces","picomatch","utils","isEmptyString","val","micromatch","list","patterns","options","concat","omit","Set","keep","items","negatives","onResult","state","add","output","i","length","isMatch","String","negated","negatedExtglob","item","matched","match","delete","result","matches","filter","has","failglob","Error","join","nonull","nullglob","unescape","map","p","replace","matcher","pattern","str","any","not","push","includes","contains","TypeError","inspect","Array","isArray","some","startsWith","slice","matchKeys","obj","isObject","keys","Object","res","key","every","all","capture","glob","input","posix","isWindows","regex","makeRe","exec","toPosixSlashes","v","args","scan","parse","nobrace","test","braceExpand","expand","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst util = require('util');\r\nconst braces = require('braces');\r\nconst picomatch = require('picomatch');\r\nconst utils = require('picomatch/lib/utils');\r\nconst isEmptyString = val => val === '' || val === './';\r\n\r\n/**\r\n * Returns an array of strings that match one or more glob patterns.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm(list, patterns[, options]);\r\n *\r\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\r\n * //=> [ 'a.js' ]\r\n * ```\r\n * @param {String|Array<string>} `list` List of strings to match.\r\n * @param {String|Array<string>} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options)\r\n * @return {Array} Returns an array of matches\r\n * @summary false\r\n * @api public\r\n */\r\n\r\nconst micromatch = (list, patterns, options) => {\r\n  patterns = [].concat(patterns);\r\n  list = [].concat(list);\r\n\r\n  let omit = new Set();\r\n  let keep = new Set();\r\n  let items = new Set();\r\n  let negatives = 0;\r\n\r\n  let onResult = state => {\r\n    items.add(state.output);\r\n    if (options && options.onResult) {\r\n      options.onResult(state);\r\n    }\r\n  };\r\n\r\n  for (let i = 0; i < patterns.length; i++) {\r\n    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);\r\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\r\n    if (negated) negatives++;\r\n\r\n    for (let item of list) {\r\n      let matched = isMatch(item, true);\r\n\r\n      let match = negated ? !matched.isMatch : matched.isMatch;\r\n      if (!match) continue;\r\n\r\n      if (negated) {\r\n        omit.add(matched.output);\r\n      } else {\r\n        omit.delete(matched.output);\r\n        keep.add(matched.output);\r\n      }\r\n    }\r\n  }\r\n\r\n  let result = negatives === patterns.length ? [...items] : [...keep];\r\n  let matches = result.filter(item => !omit.has(item));\r\n\r\n  if (options && matches.length === 0) {\r\n    if (options.failglob === true) {\r\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\r\n    }\r\n\r\n    if (options.nonull === true || options.nullglob === true) {\r\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\r\n    }\r\n  }\r\n\r\n  return matches;\r\n};\r\n\r\n/**\r\n * Backwards compatibility\r\n */\r\n\r\nmicromatch.match = micromatch;\r\n\r\n/**\r\n * Returns a matcher function from the given glob `pattern` and `options`.\r\n * The returned function takes a string to match as its only argument and returns\r\n * true if the string is a match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matcher(pattern[, options]);\r\n *\r\n * const isMatch = mm.matcher('*.!(*a)');\r\n * console.log(isMatch('a.a')); //=> false\r\n * console.log(isMatch('a.b')); //=> true\r\n * ```\r\n * @param {String} `pattern` Glob pattern\r\n * @param {Object} `options`\r\n * @return {Function} Returns a matcher function.\r\n * @api public\r\n */\r\n\r\nmicromatch.matcher = (pattern, options) => picomatch(pattern, options);\r\n\r\n/**\r\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.isMatch(string, patterns[, options]);\r\n *\r\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\r\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\r\n * ```\r\n * @param {String} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `[options]` See available [options](#options).\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nmicromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\r\n\r\n/**\r\n * Backwards compatibility\r\n */\r\n\r\nmicromatch.any = micromatch.isMatch;\r\n\r\n/**\r\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.not(list, patterns[, options]);\r\n *\r\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\r\n * //=> ['b.b', 'c.c']\r\n * ```\r\n * @param {Array} `list` Array of strings to match.\r\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\r\n * @api public\r\n */\r\n\r\nmicromatch.not = (list, patterns, options = {}) => {\r\n  patterns = [].concat(patterns).map(String);\r\n  let result = new Set();\r\n  let items = [];\r\n\r\n  let onResult = state => {\r\n    if (options.onResult) options.onResult(state);\r\n    items.push(state.output);\r\n  };\r\n\r\n  let matches = micromatch(list, patterns, { ...options, onResult });\r\n\r\n  for (let item of items) {\r\n    if (!matches.includes(item)) {\r\n      result.add(item);\r\n    }\r\n  }\r\n  return [...result];\r\n};\r\n\r\n/**\r\n * Returns true if the given `string` contains the given pattern. Similar\r\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\r\n *\r\n * ```js\r\n * var mm = require('micromatch');\r\n * // mm.contains(string, pattern[, options]);\r\n *\r\n * console.log(mm.contains('aa/bb/cc', '*b'));\r\n * //=> true\r\n * console.log(mm.contains('aa/bb/cc', '*d'));\r\n * //=> false\r\n * ```\r\n * @param {String} `str` The string to match.\r\n * @param {String|Array} `patterns` Glob pattern to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any of the patterns matches any part of `str`.\r\n * @api public\r\n */\r\n\r\nmicromatch.contains = (str, pattern, options) => {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\r\n  }\r\n\r\n  if (Array.isArray(pattern)) {\r\n    return pattern.some(p => micromatch.contains(str, p, options));\r\n  }\r\n\r\n  if (typeof pattern === 'string') {\r\n    if (isEmptyString(str) || isEmptyString(pattern)) {\r\n      return false;\r\n    }\r\n\r\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\r\n};\r\n\r\n/**\r\n * Filter the keys of the given object with the given `glob` pattern\r\n * and `options`. Does not attempt to match nested keys. If you need this feature,\r\n * use [glob-object][] instead.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.matchKeys(object, patterns[, options]);\r\n *\r\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\r\n * console.log(mm.matchKeys(obj, '*b'));\r\n * //=> { ab: 'b' }\r\n * ```\r\n * @param {Object} `object` The object with keys to filter.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Object} Returns an object with only keys that match the given patterns.\r\n * @api public\r\n */\r\n\r\nmicromatch.matchKeys = (obj, patterns, options) => {\r\n  if (!utils.isObject(obj)) {\r\n    throw new TypeError('Expected the first argument to be an object');\r\n  }\r\n  let keys = micromatch(Object.keys(obj), patterns, options);\r\n  let res = {};\r\n  for (let key of keys) res[key] = obj[key];\r\n  return res;\r\n};\r\n\r\n/**\r\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.some(list, patterns[, options]);\r\n *\r\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // true\r\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any `patterns` matches any of the strings in `list`\r\n * @api public\r\n */\r\n\r\nmicromatch.some = (list, patterns, options) => {\r\n  let items = [].concat(list);\r\n\r\n  for (let pattern of [].concat(patterns)) {\r\n    let isMatch = picomatch(String(pattern), options);\r\n    if (items.some(item => isMatch(item))) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\n/**\r\n * Returns true if every string in the given `list` matches\r\n * any of the given glob `patterns`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.every(list, patterns[, options]);\r\n *\r\n * console.log(mm.every('foo.js', ['foo.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\r\n * // true\r\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\r\n * // false\r\n * ```\r\n * @param {String|Array} `list` The string or array of strings to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if all `patterns` matches all of the strings in `list`\r\n * @api public\r\n */\r\n\r\nmicromatch.every = (list, patterns, options) => {\r\n  let items = [].concat(list);\r\n\r\n  for (let pattern of [].concat(patterns)) {\r\n    let isMatch = picomatch(String(pattern), options);\r\n    if (!items.every(item => isMatch(item))) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n};\r\n\r\n/**\r\n * Returns true if **all** of the given `patterns` match\r\n * the specified string.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.all(string, patterns[, options]);\r\n *\r\n * console.log(mm.all('foo.js', ['foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\r\n * // false\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\r\n * // true\r\n *\r\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\r\n * // true\r\n * ```\r\n * @param {String|Array} `str` The string to test.\r\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Boolean} Returns true if any patterns match `str`\r\n * @api public\r\n */\r\n\r\nmicromatch.all = (str, patterns, options) => {\r\n  if (typeof str !== 'string') {\r\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\r\n  }\r\n\r\n  return [].concat(patterns).every(p => picomatch(p, options)(str));\r\n};\r\n\r\n/**\r\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.capture(pattern, string[, options]);\r\n *\r\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\r\n * //=> ['foo']\r\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\r\n * //=> null\r\n * ```\r\n * @param {String} `glob` Glob pattern to use for matching.\r\n * @param {String} `input` String to match\r\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\r\n * @return {Array|null} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\r\n * @api public\r\n */\r\n\r\nmicromatch.capture = (glob, input, options) => {\r\n  let posix = utils.isWindows(options);\r\n  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });\r\n  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);\r\n\r\n  if (match) {\r\n    return match.slice(1).map(v => v === void 0 ? '' : v);\r\n  }\r\n};\r\n\r\n/**\r\n * Create a regular expression from the given glob `pattern`.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * // mm.makeRe(pattern[, options]);\r\n *\r\n * console.log(mm.makeRe('*.js'));\r\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\r\n * ```\r\n * @param {String} `pattern` A glob pattern to convert to regex.\r\n * @param {Object} `options`\r\n * @return {RegExp} Returns a regex created from the given pattern.\r\n * @api public\r\n */\r\n\r\nmicromatch.makeRe = (...args) => picomatch.makeRe(...args);\r\n\r\n/**\r\n * Scan a glob pattern to separate the pattern into segments. Used\r\n * by the [split](#split) method.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm.scan(pattern[, options]);\r\n * ```\r\n * @param {String} `pattern`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with\r\n * @api public\r\n */\r\n\r\nmicromatch.scan = (...args) => picomatch.scan(...args);\r\n\r\n/**\r\n * Parse a glob pattern to create the source string for a regular\r\n * expression.\r\n *\r\n * ```js\r\n * const mm = require('micromatch');\r\n * const state = mm(pattern[, options]);\r\n * ```\r\n * @param {String} `glob`\r\n * @param {Object} `options`\r\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\r\n * @api public\r\n */\r\n\r\nmicromatch.parse = (patterns, options) => {\r\n  let res = [];\r\n  for (let pattern of [].concat(patterns || [])) {\r\n    for (let str of braces(String(pattern), options)) {\r\n      res.push(picomatch.parse(str, options));\r\n    }\r\n  }\r\n  return res;\r\n};\r\n\r\n/**\r\n * Process the given brace `pattern`.\r\n *\r\n * ```js\r\n * const { braces } = require('micromatch');\r\n * console.log(braces('foo/{a,b,c}/bar'));\r\n * //=> [ 'foo/(a|b|c)/bar' ]\r\n *\r\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\r\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\r\n * ```\r\n * @param {String} `pattern` String with brace pattern to process.\r\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nmicromatch.braces = (pattern, options) => {\r\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\r\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\r\n    return [pattern];\r\n  }\r\n  return braces(pattern, options);\r\n};\r\n\r\n/**\r\n * Expand braces\r\n */\r\n\r\nmicromatch.braceExpand = (pattern, options) => {\r\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\r\n  return micromatch.braces(pattern, { ...options, expand: true });\r\n};\r\n\r\n/**\r\n * Expose micromatch\r\n */\r\n\r\nmodule.exports = micromatch;\r\n"]},"metadata":{},"sourceType":"script"}